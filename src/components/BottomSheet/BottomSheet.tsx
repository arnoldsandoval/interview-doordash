import React from 'react';
import type { FunctionComponent, ReactText } from 'react';
import { createPortal } from "react-dom";
import shortid from 'shortid';
import './BottomSheet.scss';
import { Button } from '../Button/Button'
import { useSpring, animated, config } from 'react-spring'
import { useDrag, useScroll } from 'react-use-gesture'
import {useHeight, useScrollLock } from '../../hooks'

export type Props = {
  /**
   * Describes the visibility of the BottomSheet modal.
   * @default false
   */
  visible?: boolean,

  /**
   * The contents of the BottomSheet.
   */
  children: ReactText,

  /**
   * The title shown to the user on the chrome of the BottomSheet.
   */
  title: string,
  
  /**
   * An optional descriptive string shown below the title.
   */
   description?: string,

  /**
   * An assistive, visually hidden label for the dismiss button.
   * @default "Dismiss modal"
   */
  dismissLabel?: string,

  /**
   * Determines whether the component should be shown or not.
   * @default false
   */
  isOpen?: boolean,
  
  /**
   * Callback fired when the component is **closed**.
   */
  onOpen: () => void,

  /**
   * Callback fired when the component is **opened**.
   */
  onClose: () => void
};

/** 
 * Autogenerated ID used for aria labeling purposes.
 * 
 * @todo the ID changes on every render. This is bad, it should be memoized. 
 */
const id = shortid.generate();

/**
 * The BottomSheet is a modal that appears at the bottom of the user device. It can 
 * confirm an action or display additional contextual information.
 *
 * @component
 * @example
 * <BottomSheet isOpen={boolean} onOpen={...}>
 *  Content displayed within the BottomSheet.
 * </BottomSheet>
 */
 export const BottomSheet: FunctionComponent<Props> = (props) => {
  const {
    isOpen, 
    children, 
    title, 
    description,
    dismissLabel = "Dismiss modal",
    onOpen,
    onClose,
    ...rest 
  } = props;  
  /** 
   * BottomSheet ref, used to calculate the height of the BottomSheet 
   * element, as well as halt execution of the touch handler if 
   * scrolling in the content area.
   * 
  */
  const [componentRef, height] = useHeight();
  const bottomOffset = 48;
  const h = -Math.abs(height - bottomOffset);
  const POS_SHORT = h * 0.6;
  const POS_TALL = h;

  /**
   * {@link https://react-spring.io/hooks/use-spring|react-spring docs > useSpring hook}
   */
  const [{ y }, set] = useSpring(() => ({ y: 0 }));

  /**
   * **Opens** the modal and sets it to the apropriate position based the y argument.
   * @param {boolean} cancelled - set to true when the upwards threshold is met
   * @param {number} y - The position to open the modal to along the y axis
   */
  const open = (position = 'short', type = 'wobbly') => {
    set({ 
      y: position === 'short' ? POS_SHORT : POS_TALL,
      config: config[type]
    });
  }

  /**
   * **Closes** the modal and sets it to the apropriate position based 
   * on state.
   */
  const close = () => {
    set({ 
      y: bottomOffset,
      immediate: false, 
      config: { ...config.stiff },
      onRest: () => {
        if(onClose) { onClose(); }
      }
    });
  }

  /**
   * The drag event handler, this block handles bottomsheet positioning, 
   * gestures and states.
   * 
   * It _is_ pretty big. With more time I would consider breaking it down
   * a bit more, perhaps even turning it in to a hook of its own. This would 
   * allow someone else to leverage the same BottomSheet interaction in a 
   * custom component.
   * 
   * {@link https://use-gesture.netlify.app/docs/hooks/|react-use-gesture docs > Hooks}
   */
  const dragEventHandler = ({ 
    last: isLastEvent, 
    movement: [,moveY],
    vxvy: [,velocityY], 
    cancel, 
    canceled,
    event
  }) => {
    /** If the user scrolls the content area, dont do anything! */
    const eventInContentArea = componentRef
      .current
      .querySelector('.bottom-sheet-content')
      .contains(event.target)

    if (eventInContentArea) return;

    /** 
     * Cancel drag and set position as opened if a user exceeds attempts to drag
     * the bottom sheet too high up. Doing this ensures the user does not see 
     * the bottom of the BottomSheet.
    */
    if (moveY < POS_TALL) {
      cancel();
      open('tall', 'stiff');
    }

   /** 
     * Determine the position of the BottomSheet based on the 
     * last touch event fired.
    */
    if (isLastEvent) {
      /** The isDismissed velocity int is totally arbitrary and based on feel. */ 
      const isDismissed = velocityY > 1;
      const isShort = moveY > POS_SHORT;
      const isTall = moveY > POS_TALL && !isShort;
      
      if (isShort && !isDismissed) {
        open('short');
      }
      if (isTall && !isDismissed) {
        open('tall');
      }

      if (isTall && isDismissed) {
        open('short');
      }
      
      else if (isDismissed) {
        close();
      } 
    }

    /** 
     * Otherwise let's allow the user to set the y position 
     * as they move their pointer! */
    else {
      set({ y: moveY, immediate: true });
    };
  }

  /**
   * {@link https://use-gesture.netlify.app/docs/options/|react-use-gesture docs > API Options}
   */
  const bind = useDrag(dragEventHandler, {
    initial: () => [POS_SHORT, y.get()], 
    filterTaps: true, 
    bounds: { top: POS_TALL },
    rubberband: true 
  });

  /**
   * Set position based off of the isOpen prop.
   */
  if (isOpen) {
    open('short', 'stiff');
    if (onOpen) { onOpen() } 
  } else {
    close();
  }

  useScrollLock(isOpen)
  
  /**
   * In a production setting, I would probably use a Portal 
   * component (or hook?) abstraction, allowing the developer
   * to optionally override the dom node it renders to.
   */
  return createPortal(
    <animated.aside 
      {...bind()}
      ref={componentRef}
      style={{ y }} 
      className="bottom-sheet"
      aria-labelledby={id}
      role="dialog"
      aria-modal="true"
      {...rest}
    >
      <header className="bottom-sheet-header">
        <div className="bottom-sheet-header--dismiss">
          <Button onClick={() => close()} variant="dismiss">{dismissLabel}</Button>
        </div>
        <div className="bottom-sheet-header--content">
          <h1 id={id} className="bottom-sheet-header--content-title">{title}</h1>
          {description && <p className="bottom-sheet-header--content-description">{description}</p>}
        </div>
      </header>
      <div className="bottom-sheet-content">{children}</div>
    </animated.aside>,
    document.body
  );
};